//
// build.gradle
//

import java.nio.file.*;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain

buildscript {
  ext {
    // gradle
    gradleReleasePluginVersion          = "2.7.0"
    gradleDependencyMananagementVersion = "1.0.6.RELEASE"

    // AWS
    awsSdkVersion                       = "1.11.478"
  }
  repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
    maven { url "http://maven.springframework.org/release" }
    maven { url "http://repo.spring.io/plugins-release" }
  }
  dependencies {
    classpath "com.amazonaws:aws-java-sdk-core:${awsSdkVersion}"
    classpath "com.amazonaws:aws-java-sdk-sts:${awsSdkVersion}"
  }
}

/**
 * Sets ext variable if it's not set already
 * @param name variable name
 * @param value variable value
 * @returns true if variable was set, otherwise false
 */
String setExtVar(String name, String value) {
  if (!ext.has(name)) {
    ext.set(name.toString(), value)
    return true
  }
  return false
}

boolean isResolvableConfiguration(cfg) {
  if (!cfg) return false

  // gradle >= 3.4 contains this.
  try {
    return cfg.isCanBeResolved()
  } catch (Exception e) {
  // doesn't matter, we're probably running on gradle version < 3.4
  // where all configurations are resolvable
  }
  true
}

boolean isJavadocPublishingEnabled() {
  def propName = "javadoc.enabled"
  def propVal = System.getProperty(propName)
  def envVal = System.getenv(propName.toUpperCase().replace(".", "_"))
  def value = propVal ?: envVal ?: "false"
  Boolean.parseBoolean(value)
}

def setupAwsCredentials = {
  awsCredentials ->
    def defaultCredentials = new DefaultAWSCredentialsProviderChain().getCredentials()
    awsCredentials.accessKey = defaultCredentials.getAWSAccessKeyId()
    awsCredentials.secretKey = defaultCredentials.getAWSSecretKey()
}

def createTask(String name, Class<?> type = null, Closure closure) {
  if (tasks.findByName(name)) {
    logger.info("[WARN] task $name is already defined.")
  } else {
    def task = (type == null) ? tasks.create(name) : tasks.create(name, type)
    if (closure) task.configure(closure)
  }
}

/**
 * Tells whether plugin is applied.
 * @param pluginId gradle plugin id
 * @return true if applied, otherwise false
 */
ext.isPluginApplied = { String pluginId ->
  project.getPluginManager().hasPlugin(pluginId)
}

/**
 * Fails gradle build unless specified plugin is not applied
 *
 * @param pluginId gradle pluginId
 * @param version plugin version, used only in final error message, optional
 */
ext.requireAppliedPlugin = { String pluginId, String version ->
  if (!version) version = "1.0.0"
  if (!isPluginApplied(pluginId)) {
    // weird workaround for palantir docker plugin that wants to configure itself in root project
    // as well, even if it's not applied there
    if (rootProject == project && allprojects.size() > 1) {
      logger.info("[no applied plugin: $pluginId] tolerating because root project is the same as current project.")
      return
    }

    throw new GradleException(
      "[project: ${rootProject.name} -> ${project.name}] required gradle plugin ${pluginId} is not applied.\n\n" +
      "Please add the following to build.gradle plugins {} block: id \"${pluginId}\" version \"${version}\"")
  }
}

def configureOptionalPlugin(String pluginId, Closure closure) {
  if (isPluginApplied(pluginId)) {
    apply plugin: "${pluginId}"
    closure.call()
  }
}


// dependency-management plugin is a must, build will fail if plugin is not applied
requireAppliedPlugin("io.spring.dependency-management", "1.0.6.RELEASE")

apply plugin: "java"
apply plugin: "groovy"
apply plugin: "idea"
apply plugin: "eclipse"
apply plugin: "maven"
apply plugin: "maven-publish"
apply plugin: "io.spring.dependency-management"

///////////////////////////////////////////////////////////
//                     EXT VARIABLES                     //
///////////////////////////////////////////////////////////

// groovy
setExtVar("groovyVersion",      "2.4.15")

// logging
setExtVar("slf4jVersion",       "1.7.25")
setExtVar("logbackVersion",     "1.2.3")

// testing
setExtVar("assertjVersion",     "3.10.0")
setExtVar("spockVersion",       "1.2-groovy-2.4")
setExtVar("cglibVersion",       "3.2.6")

// misc
setExtVar("lombokVersion",      "1.18.4")
setExtVar("servletVersion",     "3.1.0")
setExtVar("bugsnagVersion",     "2.0.0")
setExtVar("rxjavaVersion",      "1.3.8")
setExtVar("rxjava2Version",     "2.2.4")
setExtVar("guavaVersion",       "27.0-jre")

// swagger/springfox
setExtVar("swaggerVersion",     "1.5.10")
setExtVar("springfoxVersion",   "2.6.1")

// java compiler
setExtVar("javaSourceVersion",  "1.8")
setExtVar("javaTargetVersion",  "1.8")

///////////////////////////////////////////////////////////

allprojects {
  apply plugin: "java"
  apply plugin: "groovy"
  apply plugin: "idea"
  apply plugin: "eclipse"
  apply plugin: "maven"
  apply plugin: "maven-publish"
  apply plugin: "io.spring.dependency-management"

  repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
    maven { url "http://maven.springframework.org/release" }
    maven { url "http://repo.spring.io/plugins-release" }
    maven { url "https://oss.sonatype.org/content/repositories/releases" }
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }

    maven {
      name "ymdreleases"
      url "s3://yourmd-artifacts/maven/releases"
      credentials(AwsCredentials, setupAwsCredentials)
    }
    maven {
      name "ymdsnapshots"
      url "s3://yourmd-artifacts/maven/snapshots"
      credentials(AwsCredentials, setupAwsCredentials)
    }
  }

  // enable support for reproducible JAR archive builds
  // SEE: https://docs.gradle.org/3.5/userguide/working_with_files.html#sec:reproducible_archives
  tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps  = false
    reproducibleFileOrder   = true
  }

  plugins.withType(JavaPlugin) {
    // java bytecode version
    sourceCompatibility = "${javaSourceVersion}"
    targetCompatibility = "${javaTargetVersion}"

    // create jar only if there is something to package
    boolean hasSources = !sourceSets.main.allSource.files.isEmpty()
    jar {
      onlyIf { hasSources }
    }

    // create sources jar
    task sourcesJar(type: Jar, dependsOn: classes, overwrite: false) {
      classifier = "sources"
      from sourceSets.main.allSource, sourceSets.main.java, sourceSets.main.groovy
    }

    // javadoc options
    javadoc {
      options.encoding "UTF-8"
      options.addStringOption("Xdoclint:none", "-quiet")
    }

    task javadocJar(type: Jar, dependsOn: [classes,javadoc], overwrite: false) {
      classifier = "javadoc"
      from javadoc.destinationDir
    }

    // add compileOnly dependencies to test runtime classpath as well.
    sourceSets {
      test.compileClasspath += configurations.compileOnly
      test.runtimeClasspath += configurations.compileOnly
    }

    // set publish repos only if there are any sources to publish
    if (hasSources) {
      publishing {
        repositories {
          // https://discuss.gradle.org/t/maven-publish-specify-a-repo-as-being-a-snapshot-repo/374
          add project.version.endsWith("-SNAPSHOT") ?
              project.repositories.ymdsnapshots : project.repositories.ymdreleases
        }

        publications {
          main(MavenPublication) {
            from components.java

            if (tasks.findByName("sourcesJar")) {
              artifact sourcesJar
            }
            if (isJavadocPublishingEnabled() && tasks.findByName("javadocJar")) {
              artifact javadocJar
            }
          }
        }
      }
    }
  }

  // compile groovy sources with invokedynamic support
  tasks.withType(GroovyCompile) {
    groovyOptions.optimizationOptions.indy = true
    options.compilerArgs << "-Xlint:deprecation" << "-Xlint:unchecked"
  }

  tasks.withType(JavaCompile) {
    options.incremental = true
    options.compilerArgs << "-Xlint:deprecation" << "-Xlint:unchecked"
  }

  createTask("awsCredentials") {
    description "Displays AWS client credentials."
    doLast {
      def creds = project.repositories.ymdreleases.getCredentials(AwsCredentials)
      println("AWS accessKey: " + creds.accessKey)
      println("AWS secretKey: " + creds.secretKey)
    }
  }

  createTask("repositories") {
    description "Displays all configured repositories."
    doLast {
      project.repositories.each {
        printf("%-30s %s\n", it.name, it.url)
      }
    }
  }

  createTask("downloadDeps") {
    description "Downloads all required dependencies."
    doLast {
      project.rootProject.allprojects.each { subProject ->
        subProject.buildscript.configurations.each { configuration ->
          if (isResolvableConfiguration(configuration)) {
            println("$subProject -> $configuration")
            configuration.resolve()
          }
        }
        subProject.configurations.each { configuration ->
          if (isResolvableConfiguration(configuration)) {
            println("$subProject -> $configuration")
            configuration.resolve()
          }
        }
      }
    }
  }

  createTask("lsPlugins") {
    description "Displays enabled plugins."
    doLast { project.plugins.each { println it.getClass().getSimpleName() }}
  }

  // managed dependencies.
  dependencyManagement {
    // import BOMs
    imports {
      mavenBom "org.spockframework:spock-bom:${spockVersion}"
      mavenBom "com.amazonaws:aws-java-sdk-bom:${awsSdkVersion}"
    }

    dependencies {
      // groovy: invoke dynamic version
      dependency group: "org.codehaus.groovy", name: "groovy-all", version: "${groovyVersion}", classifier: "indy"

      // logging
      dependency "org.slf4j:slf4j-api:${slf4jVersion}"
      dependency "org.slf4j:jcl-over-slf4j:${slf4jVersion}"
      dependency "org.slf4j:log4j-over-slf4j:${slf4jVersion}"
      dependency "org.slf4j:slf4j-jdk14:${slf4jVersion}"
      dependency "org.slf4j:jul-to-slf4j:${slf4jVersion}"
      dependency "org.slf4j:slf4j-log4j12:${slf4jVersion}"
      dependency "org.slf4j:slf4j-ext:${slf4jVersion}"
      dependency "org.slf4j:slf4j-simple:${slf4jVersion}"

      dependency "ch.qos.logback:logback-access:${logbackVersion}"
      dependency "ch.qos.logback:logback-classic:${logbackVersion}"

      // misc
      dependency "io.reactivex:rxjava:${rxjavaVersion}"
      dependency "io.reactivex.rxjava2:rxjava:${rxjava2Version}"

      // swagger/springfox
      dependency "io.swagger:swagger-annotations:${swaggerVersion}"
      dependency "io.springfox:springfox-swagger2:${springfoxVersion}"
      dependency "io.springfox:springfox-swagger-ui:${springfoxVersion}"
      dependency "io.springfox:springfox-staticdocs:${springfoxVersion}"
      dependency "io.github.swagger2markup:swagger2markup-import-files-ext:1.0.0"
      dependency "io.github.swagger2markup:swagger2markup-spring-restdocs-ext:1.0.0"
      dependency "io.github.swagger2markup:swagger2markup-import-schemas-ext:1.0.0"

      // testing
      dependency "org.spockframework:spock-core:${spockVersion}"
      dependency "org.spockframework:spock-spring:${spockVersion}"
      dependency "org.spockframework:spock-specs:${spockVersion}"
      dependency "org.spockframework:spock-guice:${spockVersion}"
      dependency "org.spockframework:spock-tapestry:${spockVersion}"
      dependency "org.spockframework:spock-unitils:${spockVersion}"
      dependency "org.spockframework:spock-report:${spockVersion}"
      dependency "org.assertj:assertj-core:${assertjVersion}"
      dependency "cglib:cglib-nodep:${cglibVersion}"

      // misc
      dependency "org.projectlombok:lombok:${lombokVersion}"
      dependency "com.bugsnag:bugsnag:${bugsnagVersion}"
      dependency "javax.servlet:javax.servlet-api:${servletVersion}"
      dependency "com.google.guava:guava:${guavaVersion}"
    }
  }

  // dependencies for all projects
  dependencies {
    annotationProcessor     "org.projectlombok:lombok"
    compileOnly             "org.projectlombok:lombok"

    testAnnotationProcessor "org.projectlombok:lombok"
    testCompile             "org.slf4j:slf4j-api"
    testCompile             "org.codehaus.groovy:groovy-all"
    testCompile             "org.spockframework:spock-core"
    testCompile             "org.assertj:assertj-core"
  }

  // tests
  test {
    systemProperties  System.getProperties()
    jvmArgs           '-noverify', '-XX:TieredStopAtLevel=1'
  }

  // test-logger plugin default configuration
  if (isPluginApplied("com.adarshr.test-logger")) {
    logger.info("[${project.name}] applying test-logger plugin default config")

    apply plugin: "com.adarshr.test-logger" // otherwise config below cannot is not applied
    testlogger {
      theme         "mocha"
      slowThreshold 5000
    }
  }

  // gradle-git-properties default configuration
  if (isPluginApplied("com.gorylenko.gradle-git-properties")) {
    logger.info("[${project.name}] applying gradle-git-properties plugin default config")

    apply plugin: "com.gorylenko.gradle-git-properties" // otherwise config below cannot be applied
    gitProperties {
      dateFormat          = "yyyy-MM-dd' 'HH:mm:ssZ"
      dateFormatTimeZone  = "UTC"
      gitPropertiesDir    = "${project.buildDir}/resources/main"

      keys                = [ 'git.build.version', 'git.commit.id', 'git.commit.id.abbrev','git.commit.time' ]
    }
  }

  // groovy.version
  if (groovyVersion) {
    logger.info("[${project.name}] setting groovy.version ext property to: $groovyVersion")
    ext['groovy.version'] = "${groovyVersion}"
  }
}

  // release plugin default configuration
if (isPluginApplied("net.researchgate.release")) {
  logger.info("[${project.name}] applying release plugin default config")

  apply plugin: "net.researchgate.release" // otherwise config below cannot is not applied
  release {
    tagTemplate = 'v${version}'
  }
}

/**
 * <p>Returns modified environment variable map, with some variables removed.</p>
 * <p>Removed env variables:
 * <ul>
 * <li>variables with null or empty values</li>
 * <li>variables which contain ${} in their values</li>
 * </ul>
 * </p>
 */
ext.getCleanEnvironment = { it ->
  def res = [:]
  logger.info("Removing malformed environment variables from environment")
  System.getenv().forEach({ key, val ->
    if (key != null && val != null && !val.isEmpty() && !val.contains('$')) {
      res[key] = val
    }
  })

  if (logger.isInfoEnabled()) {
    logger.info("Returning clean evironment: ")
    res.each { logger.info(String.format(" %-30s %s", it.key, it.value)) }
  }

  res
}
if (project.tasks.test) {
  project.tasks.test.environment = getCleanEnvironment()
}

/**
 * <p>Creates copy of final artifact jar without version identifier.</p>
 * <p>Uses <i>${project.buildDir}/libs/${project.name}-${version}.jar</i> as source
 * and <i>${project.buildDir}/libs/${project.name}.jar</i> as destination
 * @return number of files copied
 * @throws IOException in case of io errors
 * @throws GradleScriptException in case of bad input
 */
ext.makeDeployArtifact = { ->
  copyFile("${project.buildDir}/libs/${project.name}-${version}.jar",
       "${project.buildDir}/libs/${project.name}.jar")
}

/**
 * Copies single file and creates missing destination directories
 * 
 * @param src source file
 * @param dsr destination filename
 * @return number of files copied
 * @throws IOException in case of io errors
 * @throws GradleScriptException in case of bad input
 */
ext.copyFile = { src, dst ->
  def srcPath = Paths.get(src)
  if (!(Files.exists(srcPath) && Files.isRegularFile(srcPath))) {
    throw new GradleScriptException("Source file doesn't exist or is not a plain file: $srcPath", null)
  }

  def parent = Paths.get(dst).getParent()
  if (!Files.isDirectory(parent)) {
    logger.warn("Creating directory: '{}'", parent)
    Files.createDirectories(parent)
  }

  // copy the file
  def dstPath = Paths.get(dst)
  logger.warn("Copying '{}' => '{}'", srcPath, dstPath)
  Files.copy(srcPath, dstPath, StandardCopyOption.REPLACE_EXISTING)

  1
}

/**
 * Copies more than many files.
 * 
 * @param dstDir destination directory as string
 * @param srcFiles source files as collection of strings
 * @return number of files copied
 * @throws IOException in case of io errors
 * @throws GradleScriptException in case of bad input
 */
ext.copyFiles = { dstDir, srcFiles ->
  int num = 0
  srcFiles.each { file ->
    def basename = Paths.get(file).getFileName()
    num += copyFile(file, "${dstDir}/${basename}")
  }
  num
}

// vim:shiftwidth=2 softtabstop=2 expandtab
// EOF
