//
// build.gradle
//

import java.nio.file.*;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain

buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
  }
  dependencies {
    classpath "com.amazonaws:aws-java-sdk-core:1.11.573"
    classpath "com.amazonaws:aws-java-sdk-sts:1.11.573"
  }
}

/**
 * Sets ext variable if it's not set already
 * @param name variable name
 * @param value variable value
 * @returns true if variable was set, otherwise false
 */
ext.setExtVar = { String name, String value ->
  if (!ext.has(name)) {
    logger.info("setting ext var {}: {}", name, value)
    ext.set(name.toString(), value)
    return true
  }
  return false
}

ext.isResolvableConfiguration = { cfg ->
  if (!cfg) return false

  // gradle >= 3.4 contains this.
  try {
    return cfg.isCanBeResolved()
  } catch (Exception e) {
  // doesn't matter, we're probably running on gradle version < 3.4
  // where all configurations are resolvable
  }
  true
}

ext.setupAwsCredentials = {
  awsCredentials ->
    def defaultCredentials = new DefaultAWSCredentialsProviderChain().getCredentials()
    awsCredentials.accessKey = defaultCredentials.getAWSAccessKeyId()
    awsCredentials.secretKey = defaultCredentials.getAWSSecretKey()
}

//def createTask2(String name, Class<?> type = null, Closure closure) {
//}
ext.createTask = { String name, Class<?> type = null, Closure closure ->
  if (tasks.findByName(name)) {
    logger.info("[WARN] task $name is already defined.")
  } else {
    def task = (type == null) ? tasks.create(name) : tasks.create(name, type)
    if (closure) task.configure(closure)
  }
}

/**
 * Tells whether plugin is applied.
 * @param pluginId gradle plugin id
 * @return true if applied, otherwise false
 */
ext.isPluginApplied = { String pluginId ->
  def result = project.getPluginManager().hasPlugin(pluginId)
  logger.info("is gradle plugin {} applied: {}", pluginId, result)
  return result
}

/**
 * Fails gradle build unless specified plugin is not applied
 *
 * @param pluginId gradle pluginId
 * @param version plugin version, used only in final error message, optional
 */
ext.requireAppliedPlugin = { String pluginId, String version ->
  if (!version) version = "1.0.0"
  if (!isPluginApplied(pluginId)) {
    // weird workaround for palantir docker plugin that wants to configure itself in root project
    // as well, even if it's not applied there
    if (rootProject == project && allprojects.size() > 1) {
      logger.info("[no applied plugin: $pluginId] tolerating because root project is the same as current project.")
      return
    }

    throw new GradleException(
      "[project: ${rootProject.name} -> ${project.name}] required gradle plugin ${pluginId} is not applied.\n\n" +
      "Please add the following to build.gradle plugins {} block: id \"${pluginId}\" version \"${version}\"")
  }
}

ext.configureOptionalPlugin = { String pluginId, Closure closure ->
  if (isPluginApplied(pluginId)) {
    apply plugin: "${pluginId}"
    closure.call()
  }
}

/**
 * Copies single file and creates missing destination directories
 * 
 * @param src source file
 * @param dsr destination filename
 * @return number of files copied
 * @throws IOException in case of io errors
 * @throws GradleScriptException in case of bad input
 */
ext.copyFile = { src, dst ->
  def srcPath = Paths.get(src)
  if (!(Files.exists(srcPath) && Files.isRegularFile(srcPath))) {
    throw new GradleScriptException("Source file doesn't exist or is not a plain file: $srcPath", null)
  }

  def parent = Paths.get(dst).getParent()
  if (!Files.isDirectory(parent)) {
    logger.warn("Creating directory: '{}'", parent)
    Files.createDirectories(parent)
  }

  // copy the file
  def dstPath = Paths.get(dst)
  logger.warn("Copying '{}' => '{}'", srcPath, dstPath)
  Files.copy(srcPath, dstPath, StandardCopyOption.REPLACE_EXISTING)

  1
}

/**
 * Copies more than many files.
 * 
 * @param dstDir destination directory as string
 * @param srcFiles source files as collection of strings
 * @return number of files copied
 * @throws IOException in case of io errors
 * @throws GradleScriptException in case of bad input
 */
ext.copyFiles = { dstDir, srcFiles ->
  int num = 0
  srcFiles.each { file ->
    def basename = Paths.get(file).getFileName()
    num += copyFile(file, "${dstDir}/${basename}")
  }
  num
}

///////////////////////////////////////////////////////////
//                     EXT VARIABLES                     //
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////

allprojects {
  apply plugin: "idea"
  apply plugin: "eclipse"

  // enable support for reproducible JAR archive builds
  // SEE: https://docs.gradle.org/3.5/userguide/working_with_files.html#sec:reproducible_archives
  tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps  = false
    reproducibleFileOrder   = true
  }

  createTask("awsCredentials") {
    group       "Misc"
    description "Displays AWS client credentials."
    doLast {
      def creds = project.repositories.ymdreleases.getCredentials(AwsCredentials)
      println("AWS accessKey: " + creds.accessKey)
      println("AWS secretKey: " + creds.secretKey)
    }
  }

  createTask("repositories") {
    group       "Misc"
    description "Displays all configured repositories."
    doLast {
      project.repositories.each {
        printf("%-30s %s\n", it.name, it.url)
      }
    }
  }

  createTask("lsPlugins") {
    group       "Misc"
    description "Displays enabled plugins."
    doLast { project.plugins.each { println it.getClass().getSimpleName() }}
  }

  // gradle-git-properties default configuration
  if (isPluginApplied("com.gorylenko.gradle-git-properties")) {
    logger.info("[${project.name}] applying gradle-git-properties plugin default config")

    apply plugin: "com.gorylenko.gradle-git-properties" // otherwise config below cannot be applied
    gitProperties {
      dateFormat          = "yyyy-MM-dd' 'HH:mm:ssZ"
      dateFormatTimeZone  = "UTC"
      gitPropertiesDir    = "${project.buildDir}/resources/main"

      keys                = [ 'git.build.version', 'git.commit.id', 'git.commit.id.abbrev','git.commit.time' ]
    }
  }
}

// release plugin default configuration
if (isPluginApplied("net.researchgate.release")) {
  logger.info("[${project.name}] applying release plugin default config")

  apply plugin: "net.researchgate.release" // otherwise config below cannot is not applied
  release {
    tagTemplate                 = 'v${version}'
    failOnSnapshotDependencies  = false
    
    git {
      // allow releases from any branch
      requireBranch             = ''
    }
  }
}

// vim:shiftwidth=2 softtabstop=2 expandtab
// EOF
